{
    "file_name": "desktop_next_appendices_architecture.html",
    "file_path": "./owncloud_docs\\desktop_next_appendices_architecture.html",
    "chunks": [
        {
            "cluster": 1,
            "chunk_content": "Documentation for ownCloud (A Kiteworks Company)\nDesktop App\nIntroduction\nInstalling the Desktop App\nUsing the Desktop App\nUsing the Virtual Filesystem\nFilename Considerations\nManage Synchronisation Conflicts\nOpen Files with Office Web Apps\nAutomatic Updating\nRemoving the Desktop App\nFAQ\nAdvanced Usage\nCommand Line Parameters\nConfiguration File\nEnvironment Variables\nLow Disk Space\nThe Command Line Client\nAppendices\nHistory and Architecture\nTroubleshooting\nDesktop App\nnext\nDesktop App\nnext\n5.3\n5.2\nInfinite Scale Documentation\nnext\n7.1\n7.0\nMobile App for Android\nnext\n4.5\n4.4\nMobile App for iOS\nnext\n12.4\n12.3\nownCloud Main Page\nownCloud Server\nnext\n10.15\n10.14\nownCloud Web User Interfaces\nnext\nDesktop App\nAppendices\nHistory and Architecture\nnext\n5.3\n5.2\nEdit this Page\nAppendix History and Architecture\nTable of Contents\nIntroduction\nThe Synchronization Process\nSynchronization by Time versus ETag\nComparison and Conflict Cases\nChecksum Algorithm Negotiation\nUpload\nChunked Upload\nDownload\nIgnored Files\nThe Sync Journal\nCustom WebDAV Properties\nServer Side Permissions\nFile- or Directory Size\nFileID\nIntroduction\nownCloud provides Desktop Apps to synchronize the contents of local directories from computers, tablets, and handheld devices to the ownCloud server. Synchronization is accomplished using\ncsync\n, a bidirectional file synchronizing tool that provides both a command line client and a library. A special module for csync was written to synchronize with the ownCloud built-in WebDAV server. The ownCloud Desktop App software is written in C++ using the\nQt Framework\nAs a result, the ownCloud Desktop App runs on Linux, Windows, and MacOS. It is important to note that the ownCloud synchronization process does not use a typical client/server system where the server is always master. This is a major difference between the ownCloud synchronization process and other systems like a file backup, where only changes to files or folders and the addition of new files are propagated, but these files and folders are never deleted unless explicitly deleted in the backup. During synchronization, the ownCloud Desktop App checks both repositories for changes frequently. Synchronization by Time versus ETag\nUntil the release of ownCloud 4.5 and ownCloud Desktop App 1.1, the ownCloud synchronization process employed a single file property — the file modification time — to decide which file was newer and needed to be synchronized to the other repository. One design goal of csync is to not require a special server component. This design goal is why csync was chosen as the backend component. Before ownCloud Desktop App version. 1.1.0, csync required both device repositories to run on the exact same time. This requirement was achieved through the use of enterprise standard\nNTP time synchronization\non all machines. Because this timing strategy is rather fragile without the use of NTP, ownCloud 4.5 introduced a unique number (for each file?) ownCloud Desktop App release 1.1 and later requires file ID capabilities on the ownCloud server. Because this is a recursive process, it significantly reduces the effort required for a synchronization cycle, because the Desktop App only analyzes directories with a modified ID. The following table outlines the different synchronization methods used, depending on server/client combination:\nTable 1. Compatibility Table\nServer Version\nDesktop App Version\nSync Methods\n4.0.x or earlier\n1.0.5 or earlier\nTime Stamp\n4.0.x or earlier\n1.1 or later\nn/a (incompatible)\n4.5 or later\n1.0.5 or earlier\nTime Stamp\n4.5 or later\n1.1 or later\nFile ID, Time Stamp\nWe strongly recommend using ownCloud Server release 4.5 or later when using ownCloud Desktop App 1.1 or later. Using an incompatible time stamp-based synchronization mechanism can lead to data loss in rare cases, especially when multiple Desktop Apps are involved and one utilizes a non-synchronized NTP time. For the remote (that is, ownCloud server) repository, the Desktop App compares the ETag of each file with its expected value. Ignored Files\nThe ownCloud Desktop App supports the ability to exclude or ignore certain files from the synchronization process. Some system-wide file patterns that are used to exclude or ignore files are included with the Desktop App by default and the ownCloud Desktop App provides the ability to add custom patterns. By default, the ownCloud Desktop App ignores the following files:\nFiles matched by one of the patterns defined in the Ignored Files Editor. sync\n*.db*\n,\n.sync_*.db*\n,\n.csync_journal.db*\n,\n.owncloudsync.log*\n, as these files are reserved for journaling. If the journal database is removed, the ownCloud Desktop App CSync backend rebuilds the database by comparing the files and their modification times. This process ensures that both server and Desktop App are synchronized using the appropriate NTP time before restarting the Desktop App following a database removal. Custom WebDAV Properties\nIn the communication between Desktop App and server a couple of custom WebDAV properties were introduced. They are either needed for sync functionality or help have a positive effect on synchronization performance. Example:\n<oc:id>00000020oc5cfy6qqizm</oc:id>\nThe Command Line Client\nTroubleshooting\nAbout ownCloud\nThe Secure Collaboration Platform\nNews\nPrivacy statement\nImprint\nResources\nFAQ\nHelp\nSecurity\nChangelog\nGet started\nInteract\nRocket.Chat\nForum\nContribute\nCustomer support\n© Copyright 2011-2025, The ownCloud developers."
        },
        {
            "cluster": 2,
            "chunk_content": "The Synchronization Process\nThe process of synchronization keeps files in two separate repositories the same. When synchronized:\nIf a file is added to one repository it is copied to the other synchronized repository. When a file is changed in one repository, the change is propagated to any other synchronized repository. If a file is deleted in one repository, it is deleted in any other. This process is referred to as a\nsync run\n. In between sync runs, the local repository is monitored by a file system monitoring process that starts a sync run immediately if something was edited, added, or removed. The\nmodification timestamp\nis part of the file’s metadata. It is available on every relevant filesystem and is the typical indicator for a file change. Modification timestamps do not require special action to create, and have a general meaning. To compare the modification times of two files from different systems, csync must operate on the same base. that changes whenever the file changes. Because the file number changes if the file changes, its use is guaranteed to determine if one of the files has changed and, thereby, launching a synchronization process. Before the 1.3.0 release of the Desktop App, the synchronization process might create false conflict files if time deviates. Original and changed files conflict only in their timestamp, but not in their content. This behavior was changed to employ a binary check if files differ. Comparison and Conflict Cases\nAs mentioned above, during a\nsync run\nthe Desktop App must first detect if one of the two repositories have changed files. On the local repository, the Desktop App traverses the file tree and compares the modification time of each file with an expected value stored in its database. If the value is not the same, the Desktop App determines that the file has been modified in the local repository. On the local side, the modification time is a good attribute to use for detecting changes, because the value does not depend on time shifts and such. If the ETag is the same, the file has not changed and no synchronization occurs. In the event a file has changed on both the local and the remote repository since the last sync run, it can not easily be decided which version of the file is the one that should be used. However, changes to any side will not be lost. Instead, a\nconflict case\nis created. The Desktop App resolves this conflict by renaming the local file, appending a conflict label and timestamp, and saving the remote file under the original file name. Example:\nAssume there is a conflict in message.txt because its contents have changed both locally and remotely since the last sync run. The local file with the local changes will be renamed to\nmessage. (conflicted copy 2016-01-01 153110).txt\nand the remote file will be downloaded and saved as message.txt. Conflict files are always created on the Desktop App and never on the server. The file\nDesktop.ini\nin the root of a synced folder. These files are ignored and\nremoved\nby the Desktop App if found in the synchronized folder. The path that is checked is the relative path under the sync root directory. Pattern\nFile Matches\n~$*\n~$foo\n,\n~$example.doc\nfl?p\nflip\n,\nflap\nmoo/\nmap/moo/\n,\nmoo/\nThe Sync Journal\nThe Desktop App stores the ETag number in a per-directory database, called the\njournal\n. This database is a hidden file contained in the directory to be synchronized. It is not changed if the file changes or is renamed or moved."
        },
        {
            "cluster": 0,
            "chunk_content": "Although this number is a unique value, it is not a hash of the file. Instead, it is a randomly chosen number, that is transmitted in the\nEtag\nfield. Servers that run with release earlier than 4.5.0 do not support using the file ID functionality. Again, the expected ETag value is queried from the Desktop App database. Checksum Algorithm Negotiation\nIn ownCloud 10.0 we implemented a checksum feature which checks the file integrity on upload and download by computing a checksum after the file transfer finishes. The Desktop App queries the server capabilities after login to decide which checksum algorithm to use. Currently, SHA1 is hard-coded in the official server release and can’t be changed by the end-user. Note that the server additionally also supports\nMD5\nand\nAdler-32\n, but the Desktop App will always use the checksum algorithm announced in the capabilities:\nGET http://localhost:8000/ocs/v1.php/cloud/capabilities?format=json\n{\n\"ocs\":{\n\"meta\":{\n\"status\":\"ok\",\n\"statuscode\":100,\n\"message\":\"OK\",\n\"totalitems\":\"\",\n\"itemsperpage\":\"\"\n},\n\"data\":{\n\"version\":{\n\"major\":10,\n\"minor\":0,\n\"micro\":0,\n\"string\":\"10.0.0 beta\",\n\"edition\":\"Community\"\n},\n\"capabilities\":{\n\"core\":{\n\"pollinterval\":60,\n\"webdav-root\":\"remote.php/webdav\"\n},\n\"dav\":{\n\"chunking\":\"1.0\"\n},\n\"files_sharing\":{\n\"api_enabled\":true,\n\"public\":{\n\"enabled\":true,\n\"password\":{\n\"enforced\":false\n},\n\"expire_date\":{\n\"enabled\":false\n},\n\"send_mail\":false,\n\"upload\":true\n},\n\"user\":{\n\"send_mail\":false\n},\n\"resharing\":true,\n\"group_sharing\":true,\n\"federation\":{\n\"outgoing\":true,\n\"incoming\":true\n}\n},\n\"checksums\":{\n\"supportedTypes\":[\n\"SHA1\"\n],\n\"preferredUploadType\":\"SHA1\"\n},\n\"files\":{\n\"bigfilechunking\":true,\n\"blacklisted_files\":[\n\".htaccess\"\n],\n\"undelete\":true,\n\"versioning\":true\n}\n}\n}\n}\n}\nUpload\nA checksum is calculated with the previously negotiated algorithm by the Desktop App and sent along with the file in an HTTP Header:\nOC-Checksum: [algorithm]:[checksum]\n. During file upload, the server computes SHA1, MD5, and Adler-32 checksums and compares one of them to the checksum supplied by the Desktop App. On mismatch, the server returns HTTP Status code 400 (Bad Request) thus signaling the Desktop App that the upload failed. The server then discards the upload, and the Desktop App blacklists the file:\n<?xml version='1.0' encoding='utf-8'?>\n<d:error xmlns:d=\"DAV:\" xmlns:s=\"http://sabredav.org/ns\">\n<s:exception>Sabre\\DAV\\Exception\\BadRequest</s:exception>\n<s:message>The computed checksum does not match the one received from the client.</s:message>\n</d:error>\nThe Desktop App retries the upload using exponential back-off. On success, (matching checksum) the computed checksums are stored by the server in\noc_filecache\nalongside the file. Chunked Upload\nMostly same as above. The checksum of the full file is sent with every chunk of the file. But the server only compares the checksum after receiving the checksum sent with the last chunk. Download\nThe server sends the checksum in an HTTP header with the file. (same format as above) If no checksum is found in\noc_filecache\n(freshly mounted external storage) it is computed and stored in\noc_filecache\non the first download. The checksum is then provided on all subsequent downloads but not on the first. fleeting meta data\n. This chapter describes additional XML elements which the server returns in response to a successful\nPROPFIND\nrequest on a file or directory. Server Side Permissions\nThe XML element\n<oc:permissions>\nrepresents the permission- and sharing state of the item. It is a non-volatile string id that stays constant as long as the file exists."
        },
        {
            "cluster": 4,
            "chunk_content": "Like files, directories also hold a unique ID that changes whenever one of the contained files or directories is modified. Files starting with\n. Files with a name longer than 254 characters. Windows only: Files with a trailing space or dot. Windows only: Filenames that are reserved on Windows. This is suitable for meta files created by some applications that have no sustainable meaning. The elements are returned in the namespace\noc\n. It is a list of characters, and each of the chars has a meaning as outlined in the table below:\nCode\nResource\nDescription\nS\nFile or Folder\nis shared. R\nFile or Folder\ncan share (includes re-share)\nM\nFile or Folder\nis mounted (like on Dropbox, Samba, etc.) W\nFile\ncan write file. C\nFolder\ncan create file in folder. K\nFolder\ncan create folder (mkdir)\nD\nFile or Folder\ncan delete file or folder. N\nFile or Folder\ncan rename file or folder. V\nFile or Folder\ncan move file or folder. Example:\n<oc:permissions>RDNVCK</oc:permissions>\nFile- or Directory Size\nThe XML element\n<oc:size>\nrepresents the file- or directory size in bytes. For directories, the size of the whole file tree underneath the directory is accumulated. Example:\n<oc:size>2429176697</oc:size>\nFileID\nThe XML element\n<oc:id>\nrepresents the so-called file ID."
        },
        {
            "cluster": 3,
            "chunk_content": "Files matching the pattern\n_conflict-\nunless conflict file uploading is enabled. Files matching the pattern\n(conflicted copy\nunless conflict file uploading is enabled. Windows only: Files containing characters that do not work on typical Windows filesystems\n(\\, /, :, ?, *, \", >, <, |)\n. If a pattern selected using a checkbox in the\nIgnored Files Editor\n, or if a line in the exclude file starts with the character\n]\ndirectly followed by the file pattern, files matching the pattern are considered. If a pattern ends with the forward slash (\n/\n) character, only directories are matched. The pattern is only applied for directory components of filenames selected using the checkbox. To match filenames against the exclude patterns, the UNIX standard C library function\nfnmatch\nis used. This process checks the filename against the specified pattern using standard shell wildcard pattern matching. For more information, please refer to\nthe pattern matching documentation\n. Pattern and File Match Examples:\n."
        }
    ]
}