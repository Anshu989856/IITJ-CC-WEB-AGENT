{
    "file_name": "ocis_7.0_architecture_architecture.html",
    "file_path": "./owncloud_docs\\ocis_7.0_architecture_architecture.html",
    "chunks": [
        {
            "cluster": 2,
            "chunk_content": "Documentation for ownCloud (A Kiteworks Company)\nInfinite Scale Documentation\nIntroduction\nQuick Guide\nInfinite Scale Overview\nArchitecture and Concepts\nAvailability and Scalability\nSecurity Aspects\nDeployment\nPrerequisites\nStorage\nGeneral Storage Considerations\nNetwork File System\nS3\nPosixFS\nGeneral Information\nThe ocis init Command\nContainer Orchestration\nOffice Applications using WOPI\nSecuring oCIS\nUser Triggered GDPR Report\nServices\nGeneral Information\nDeployment Considerations\nEnvironment Variable Notes\nEnvironment Variables with Special Scope\nEnvironment Variable Changes\nRegistry\nCaching and Persistence\nGateways\nLogging\nPorts Used\nTransport Layer Security\nList of Services\nActivitylog\nAntivirus\nApp Provider\nApp Registry\nAudit\nAuth App\nAuth Basic\nAuth Bearer\nAuth Machine\nAuth Service\nClientlog\nCollaboration\nEventhistory\nFrontend\nGateway\nGraph\nGroups\nIDM\nInvitations\nIDP\nNATS\nNotifications\nOCDAV\nOCM\nOCS\nPolicies\nPostprocessing\nProxy\nSearch\nSettings\nSharing\nSSE\nStore\nStorage-Publiclink\nStorage-Shares\nStorage-System\nStorage-Users\nThumbnails\nUserlog\nUsers\nWeb\nWebDAV\nWebfinger\nWeb UI\nCustom Configuration\nCustom Theming\nMaintenance\nBackup and Restore\nBackup Considerations\nBackup\nRestore\nMaintenance Commands\nListing Space IDs\nListing User IDs\nMigration and Upgrades\nUpgrading Infinite Scale\nMonitoring\nPrometheus\nConfiguration Examples\nOffice Integration\nSearch\nDeployment Examples\nMinimal Bare Metal\nBare Metal with systemd\nContainer Setup\nUbuntu with Docker Compose\nLocal Production Setup\nDeployment on Hetzner\nSetup Federations\nScienceMesh Setup\nAdditional Information\nKnowledge Base\nInfinite Scale Documentation\n7.0\nDesktop App\nnext\n5.3\n5.2\nInfinite Scale Documentation\nnext\n7.1\n7.0\nMobile App for Android\nnext\n4.5\n4.4\nMobile App for iOS\nnext\n12.4\n12.3\nownCloud Main Page\nownCloud Server\nnext\n10.15\n10.14\nownCloud Web User Interfaces\nnext\nInfinite Scale Documentation\nInfinite Scale Overview\nArchitecture and Concepts\nnext\n7.1\n7.0\nEdit this Page\nArchitecture and Concepts of Infinite Scale\nTable of Contents\nIntroduction\nArchitecture Overview\nC4 Model\nConcepts\nFunctional Concepts\nSpaces\nFederated Storage\nRuntime Concepts\nInfinite Scale Microservice Runtime\nInfinite Scale Services\nGo-Micro\nREVA and CS3\nProtocol-Driven Development\nIntroduction\nThis page gives you an overview of the architecture and the concepts behind Infinite Scale. Infinite Scale was designed from the beginning as a data platform providing tools to integrate, organize, share and govern data and metadata. These topics have always been kept in mind during the development of Infinite Scale:\ndata platform\nunified data access\ncloud data ecosystems\nsupport of the customers data strategy\nArchitecture Overview\nLooking at the image below, you see that the state of classic file sharing is not sufficient for today’s requirements and the trend clearly heads toward services around data and metadata. This is the basis of the Infinite Scale architecture. C4 Model\nWe use the C4 model to visualise the software architecture of Infinite Scale. — © Wikipedia\nC4 Model\nUse this link to download the\nInfinite Scale C4 Model\nraw description file. Federated Storage\nTo create a truly federated storage architecture, Infinite Scale breaks down the ownCloud 10 user-specific namespace, which is assembled on the server side, and makes the individual parts accessible to clients as storage spaces and storage space registries. Runtime Concepts\nInfinite Scale Microservice Runtime\nInfinite Scale runtime allows us to dynamically manage services running in a single process. By default, Infinite Scale will start all built-in Infinite Scale services in a single process. Individual services can be moved to other nodes to scale out and meet specific performance requirements. A\ngo-micro-based\nregistry allows services in multiple nodes to form a distributed microservice architecture. Infinite Scale Services\nEvery Infinite Scale service uses\nocis-pkg\n, which implements the go-micro interfaces for servers to register and clients to look up nodes with a service registry. We are following the 12-factor methodology with Infinite Scale. Configurations are forwarded from the Infinite Scale runtime to the individual services. Go-Micro\nWhile the\ngo-micro\nframework provides abstractions as well as implementations for the different components in a microservice architecture, it uses a more developer-focused runtime philosophy: It is used to download services from a repo, compile them on the fly and start them as individual processes. For Infinite Scale we decided to use a more admin-friendly runtime: You can download a single binary and start the contained Infinite Scale services with a single command:\nocis server\n. REVA and CS3\nA lot of embedded services in Infinite Scale are built on the\nREVA\nruntime. CS3 (Cloud Storage Services for Synchronization and Sharing) is based on\nGRPC\n(open source high performance Remote Procedure Call (RPC) framework) which uses a binary-coded versionable payload protocol with much higher efficiency when it comes to parsing compared to a classical XML payload. Protocol-Driven Development\nInteracting with Infinite Scale involves a multitude af APIs. Clients use the\nWebDAV\n-based\nownCloud sync protocol\nto manage files and folders, Open Collaboration Services (OCS) to manage shares and\nTUS\nto upload files in a resumable way. Quick Guide\nAvailability and Scalability\nAbout ownCloud\nThe Secure Collaboration Platform\nNews\nPrivacy statement\nImprint\nResources\nFAQ\nHelp\nSecurity\nChangelog\nGet started\nInteract\nRocket.Chat\nForum\nContribute\nCustomer support\n© Copyright 2011-2025, The ownCloud developers."
        },
        {
            "cluster": 0,
            "chunk_content": "Iron-cast structures do not allow for additional value that could be created out of data and metadata. Services available to clients like end users or management have to be able to follow different and dynamic requirements. The C4 model is a lean graphical notation technique for modelling the architecture of software systems. It is based on a structural decomposition of a system into containers and components and relies on existing modelling techniques such as the Unified Modelling Language (UML) or Entity Relation Diagrams (ERD) for the more detailed decomposition of the architectural building blocks. They organize a set of resources in a hierarchical tree. free space, quota, managers, syncable, root\nETag\netc. For details see the\nRAM Considerations\n. There might be multiple storage providers, either to shard the load, provide different levels of redundancy or support custom workflows. We use\nsuture\nto create a supervisor tree that starts each service in a dedicated Go routine. The uniformity of services also allows us to use the same mechanism for commands, logging and configuration. This also makes packaging easier. We decided to bundle some of the CS3 services to logically group them. A home storage provider, which is dealing with metadata, and the corresponding data provider, which is dealing with uploads and downloads, are one example."
        },
        {
            "cluster": 1,
            "chunk_content": "Concepts\nFunctional Concepts\nSpaces\nSpaces are a logical concept. Here are some key features:\nInternally, a space is identified by a unique\nstorage space ID\nand displayed to users by a given name. A space has no owner, though one or more users can be assigned to manage a space. Access to a space is granted via roles assigned to users, groups and guests like member, manager etc. Each space can have an individual:\nDescription\nImage\nQuota\nA storage spaces registry then allows listing the capabilities of storage spaces, e.g. Spaces may serve different purposes like every user’s personal storage space, project, group or school class storage spaces including shares and reshares. A space makes it much easier to separate data that can be shared and data that should not be shared. As an example, although you can share content in your personal space, it is much more secure to have a dedicated space for sharing and keep your personal space for your eyes only. Spaces have a small memory footprint and are therefore very effective. For detailed information on the implementation of spaces, check out the\nDeveloper Guide\n. The diagram below shows the core concepts of the new architecture:\nEnd-user devices can fetch the list of storage spaces a user has access to by querying one or multiple storage space registries. The list contains a unique endpoint for every storage space. Storage space registries manage the list of storage spaces a user has access to. They may subscribe to storage spaces in order to receive notifications about changes on behalf of an end-user’s mobile or desktop client. Storage spaces represent a collection of files and folders. A user’s personal files are contained in a storage space. A group or project drive is a storage space. Even incoming shares are treated and implemented as storage spaces, each with properties like owners, permissions, quota and type. Storage providers can hold multiple storage spaces. On an Infinite Scale instance, there might be a dedicated storage provider responsible for users' personal storage spaces. Or there might be just one, hosting all types of storage spaces. It contains the most specific storage space ID and a path relative to it:\nhttps://cloud.zurich.test/#/spaces/716199a6-00c0-4fec-93d2-7e00150b1c84/a/rel/path\n."
        },
        {
            "cluster": 3,
            "chunk_content": "For example,\nEinstein\nwants to share something with\nMarie\n, who has an account at a\ndifferent\nidentity provider and uses a different storage space registry. Einstein\nopens\nhttps://cloud.zurich.test\n. For\neinstein@zurich.test\n, he will end up at\nhttps://idp.zurich.test\n, authenticate and get redirected back to\nhttps://cloud.zurich.test\n. Now, Infinite Scale Web will use a similar discovery to look up the storage space registry for the account based on the email address (or username). He will discover that\nhttps://cloud.zurich.test\nis also his storage registry which the Web UI will use to load the list of storage spaces available to him. After locating a folder that\nEinstein\nwants to share with\nMarie\n, he enters her email address\nmarie@paris.test\nin the sharing dialog to grant her the editor role. This, in effect, creates a new storage space that is registered with the storage space registry at\nhttps://cloud.zurich.test\n. Einstein\ncopies the URL in the browser (or an email with the same URL is sent automatically, or the storage registries use a back-channel mechanism). When\nMarie\nenters that URL, she will be presented with a login form on the\nhttps://cloud.zurich.test\ninstance, because the share was created on that domain. This time, the storage space registry discovery will come up with\nhttps://cloud.paris.test\nthough. Since that registry is different than the registry tied to\nhttps://cloud.zurich.test\n, Infinite Scale Web can look up the storage space\n716199a6-00c0-4fec-93d2-7e00150b1c84\nand register the WebDAV URL\n\\https:/cloud.zurich.test/dav/spaces/716199a6-00c0-4fec-93d2-7e00150b1c84/a/rel/path\nin Marie`s storage space registry at\nhttps://cloud.paris.test\n. When\nMarie\naccepts that share, her clients will be able to sync the new storage space at\nhttps://cloud.zurich.test\n."
        },
        {
            "cluster": 4,
            "chunk_content": "OpenID Connect (OIDC) is used for authentication. His browser loads Infinite Scale Web and presents a login form that uses OpenID Connect Discovery to look up the OIDC issuer. If\nhttps://cloud.zurich.test\ntrusts her OpenID Connect identity provider\nhttps://idp.paris.test\n, she can log in. Reva is the\nCS3 API\nreference implementation. The frontend with the oc-flavoured WebDAV, OCS handlers and a data gateway are another. The server and all clients rely on\nOpenID Connect\nfor authentication. The embedded LibreGraph Connect can be replaced with any other OpenID Connect Identity Provider. On the server side, REVA is the reference implementation of the\nCS3APIS\n, which are defined using protocol buffers. By embedding Go-lang LDAP Authentication (GLAuth), Infinite Scale provides a read-only LDAP interface to make accounts, including guests, available to firewalls and other systems."
        }
    ]
}